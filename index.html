<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Chess Tournament Manager</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg: #f8f9fb;
            --sidebar-bg: #20252b;
            --sidebar-active: #2f88ff;
            --text: #1b1f23;
            --border: #d0d7de;
            --danger: #d92d3a;
            --success: #2e8540;
            --warning: #f6c344;
            --radius: 6px;
            --accent: #4caf50;
            --muted: #666;
            font-size: 16px;
        }
        * { box-sizing: border-box; }
        body,html { margin:0; padding:0; font-family: system-ui,-apple-system,"Segoe UI",Arial,sans-serif; background: var(--bg); color: var(--text); }
        body { display:flex; min-height:100vh; }
        /* Sidebar */
        .sidebar { width:250px; background: var(--sidebar-bg); color:#fff; display:flex; flex-direction:column; padding:18px 16px; }
        .sidebar h1 { font-size:1.1rem; margin:0 0 14px; font-weight:600; letter-spacing:.5px; }
        .nav-item { padding:10px 12px; margin-bottom:6px; border-radius: var(--radius); cursor:pointer; user-select:none; display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,0.06); }
        .nav-item span { font-size:.9rem; }
        .nav-item.active { background: var(--sidebar-active); font-weight:600; }
        .nav-item.disabled { opacity:.4; cursor:not-allowed; }
        .nav-item:not(.disabled):hover { background:#3a4752; }
        .version { margin-top:auto; font-size:.7rem; opacity:.6; }
        /* Main */
        .main { flex:1; padding:24px 28px 40px; overflow-y:auto; }
        .main h2 { margin:0 0 14px; font-weight:600; }
        .actions { display:flex; gap:10px; flex-wrap:wrap; margin-bottom:12px; }
        button, .btn { background:#fff; border:1px solid var(--border); padding:8px 14px; border-radius:var(--radius); font-size:.85rem; cursor:pointer; display:inline-flex; gap:6px; align-items:center; line-height:1.2; }
        button:hover { background:#f0f3f6; }
        button.primary { background: var(--accent); color:#fff; border-color: var(--accent); }
        button.primary:hover { background:#3d9447; }
        button.danger { background: var(--danger); color:#fff; border-color: var(--danger); }
        button.danger:hover { background:#b3202c; }
        button.outline { background:transparent; }
        table { width:100%; border-collapse:collapse; margin-bottom:20px; background:#fff; border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; }
        thead { background:#eef2f6; }
        th,td { padding:8px 10px; font-size:.8rem; text-align:left; border-bottom:1px solid var(--border); }
        tbody tr:last-child td { border-bottom:none; }
        tbody tr:hover { background:#f8fbff; }
        .tag { display:inline-block; padding:2px 6px; font-size:.65rem; border-radius:999px; background:#dde7f2; text-transform:uppercase; letter-spacing:.5px; font-weight:600; }
        .tag.manual { background:#ffe6cc; color:#a35300; }
        .tag.auto { background:#e2f7e2; color:#256327; }
    .tag.applied { background:#d4f1ff; color:#004b74; }
        .checkbox-center { text-align:center; }
        .muted { color: var(--muted); font-size:.7rem; }
        .no-partner { font-weight:600; background:#fafaa7; padding:2px 6px; border-radius:4px; }
    .rate-up { color:#2e8540; font-size:.7rem; font-weight:700; margin-left:4px; }
    .rate-down { color:#d92d3a; font-size:.7rem; font-weight:700; margin-left:4px; }
        /* Layout helpers */
        .flex { display:flex; }
        .flex.gap { gap:12px; }
        .flex.col { flex-direction:column; }
        .grow { flex:1; }
        .hidden { display:none !important; }
        .divider { height:1px; background:#e1e4e8; margin:16px 0; }
        .center { text-align:center; }
        /* Modal */
        .modal-backdrop { position:fixed; inset:0; background:rgba(0,0,0,.45); display:flex; align-items:flex-start; justify-content:center; padding:60px 20px; z-index:100; }
        .modal { background:#fff; width:420px; max-width:100%; border-radius:var(--radius); box-shadow:0 10px 28px -6px rgba(0,0,0,.3); border:1px solid var(--border); animation:pop .18s ease-out; }
        @keyframes pop { from { transform:translateY(12px); opacity:0; } to { transform:translateY(0); opacity:1; } }
        .modal header { padding:14px 18px 10px; font-weight:600; border-bottom:1px solid var(--border); }
        .modal .content { padding:16px 18px 10px; }
        .modal .actions { padding:10px 18px 18px; border-top:1px solid var(--border); justify-content:flex-end; }
        .modal label { display:block; font-size:.7rem; text-transform:uppercase; letter-spacing:.5px; margin:10px 0 4px; font-weight:600; }
        .modal input[type=text],
        .modal input[type=number],
        .modal select { width:100%; padding:7px 8px; border:1px solid var(--border); border-radius:var(--radius); font-size:.8rem; background:#fff; }
        .danger-text { color: var(--danger); font-weight:600; }
        .scroll-y { max-height:320px; overflow-y:auto; }
        .mini { font-size:.65rem; padding:3px 8px; }
        .w50 { width:50%; }
        .table-wrapper { overflow-x:auto; }

        /* Mobile Menu Toggle */
        .mobile-menu-toggle { display:none; position:fixed; top:16px; left:16px; z-index:200; background:var(--sidebar-bg); color:#fff; border:none; padding:8px 12px; border-radius:var(--radius); cursor:pointer; }
        .mobile-menu-toggle:hover { background:#3a4752; }
        .sidebar-overlay { display:none; position:fixed; inset:0; background:rgba(0,0,0,0.5); z-index:150; }

        /* Responsive Design */

        /* Mobile devices (phones) - up to 767px */
        @media (max-width: 767px) {
            :root { font-size: 14px; }

            body { flex-direction:column; }

            .mobile-menu-toggle { display:block; }

            .sidebar {
                position:fixed;
                top:0; left:0;
                width:280px;
                height:100vh;
                z-index:160;
                transform:translateX(-100%);
                transition:transform 0.3s ease;
                padding-top:60px;
            }
            .sidebar.mobile-open { transform:translateX(0); }
            .sidebar-overlay.show { display:block; }

            .main {
                padding:60px 16px 24px;
                margin-left:0;
                min-height:calc(100vh - 60px);
            }

            .main h2 { font-size:1.3rem; margin-bottom:12px; }

            .actions {
                flex-direction:column;
                gap:8px;
                margin-bottom:16px;
            }
            .actions button {
                width:100%;
                justify-content:center;
                padding:12px 16px;
            }

            /* Make manual pairing form stack vertically on mobile */
            .manual-pairing-form {
                flex-direction:column !important;
                max-width:100% !important;
                gap:12px !important;
            }
            .manual-pairing-form > div {
                flex:1 1 auto !important;
                width:100% !important;
            }
            .manual-pairing-form button {
                width:100% !important;
                margin-top:8px;
            }

            /* Algorithm settings responsive */
            .algorithm-settings {
                flex-direction:column !important;
                align-items:flex-start !important;
                gap:12px !important;
            }
            .algorithm-settings > * {
                width:100%;
            }

            /* Manual pair items responsive - more compact for mobile */
            .manual-pair-item {
                flex-direction:row !important;
                align-items:center !important;
                gap:6px !important;
                font-size:0.75rem !important;
                min-height:auto !important;
            }
            .manual-pair-info {
                flex-direction:row !important;
                align-items:center !important;
                gap:4px !important;
                flex:1 !important;
                overflow:hidden;
            }
            .manual-pair-info > div:first-child {
                flex:0 0 60px !important;
                font-size:0.7rem !important;
                font-weight:600 !important;
            }
            .manual-pair-info > div:nth-child(2),
            .manual-pair-info > div:nth-child(4) {
                flex:1 1 auto !important;
                white-space:nowrap;
                overflow:hidden;
                text-overflow:ellipsis;
                font-size:0.7rem !important;
            }
            .manual-pair-info > div:nth-child(3) {
                flex:0 0 auto !important;
                font-size:0.65rem !important;
                margin:0 2px !important;
            }
            .manual-pair-controls {
                flex:0 0 auto !important;
                gap:4px !important;
            }
            .manual-pair-controls .tag {
                font-size:0.55rem !important;
                padding:1px 4px !important;
            }
            .manual-pair-controls .mini {
                font-size:0.6rem !important;
                padding:2px 6px !important;
            }

            /* Make manual pair containers more compact on mobile */
            .manual-pair-container {
                padding:4px 6px !important;
                margin-bottom:4px !important;
            }

            /* Tables responsive */
            table { font-size:.7rem; }
            th,td { padding:6px 4px; }

            /* Hide less important columns on mobile */
            .mobile-hide { display:none; }

            /* Modal adjustments */
            .modal-backdrop { padding:20px 16px; align-items:center; }
            .modal { width:100%; max-width:360px; }
            .modal .content { padding:16px; }
            .modal .actions { flex-direction:column; gap:8px; }
            .modal .actions button { width:100%; }
        }

        /* Tablet devices - 768px to 1024px */
        @media (min-width: 768px) and (max-width: 1024px) {
            :root { font-size: 15px; }

            .sidebar { width:220px; padding:16px 14px; }

            .main { padding:20px 24px 32px; }

            .actions { gap:8px; }
            .actions button { font-size:.8rem; padding:10px 12px; }

            /* Manual pairing form adjustments for tablet */
            .manual-pairing-form {
                flex-wrap:wrap !important;
                gap:8px !important;
            }
            .manual-pairing-form > div:nth-child(1) { flex:0 0 100px !important; }
            .manual-pairing-form > div:nth-child(2),
            .manual-pairing-form > div:nth-child(3) { flex:1 1 180px !important; }
            .manual-pairing-form > div:nth-child(4) { flex:0 0 auto !important; }

            /* Algorithm settings for tablet */
            .algorithm-settings {
                flex-wrap:wrap !important;
                gap:16px !important;
            }

            table { font-size:.75rem; }
            th,td { padding:7px 8px; }
        }

        /* Desktop devices - 1025px and up */
        @media (min-width: 1025px) {
            .main { padding:24px 32px 40px; }

            /* Larger screens can show more content */
            .table-wrapper table { font-size:.85rem; }
            th,td { padding:10px 12px; }
        }

        /* Ultra-wide screens - 1440px and up */
        @media (min-width: 1440px) {
            .main { max-width:1400px; margin:0 auto; padding:24px 40px 40px; }

            .sidebar { width:280px; padding:20px 18px; }
            .sidebar h1 { font-size:1.2rem; }

            .manual-pairing-form {
                max-width:1100px !important;
            }
        }

        /* Touch-friendly improvements */
        @media (hover: none) and (pointer: coarse) {
            button, .btn {
                min-height:44px;
                padding:12px 16px;
                font-size:.9rem;
            }
            .mini {
                min-height:36px;
                padding:8px 12px;
                font-size:.75rem;
            }
            input[type="checkbox"] {
                width:18px;
                height:18px;
                margin-right:8px;
            }
            .nav-item {
                padding:12px;
                margin-bottom:8px;
            }
        }

        /* Print styles */
        @media print {
            .sidebar, .mobile-menu-toggle, .sidebar-overlay { display:none !important; }
            .main { margin-left:0 !important; padding:12px !important; }
            .actions { display:none !important; }
            .mobile-hide { display:table-cell !important; }
            button { display:none !important; }
        }
    </style>
</head>
<body>
    <!-- Mobile menu toggle -->
    <button class="mobile-menu-toggle" onclick="toggleMobileMenu()">☰ Menu</button>

    <!-- Sidebar overlay for mobile -->
    <div class="sidebar-overlay" onclick="closeMobileMenu()"></div>

    <aside class="sidebar" id="sidebar">
        <h1>Chess Manager</h1>
        <div id="navPlayers" class="nav-item active" onclick="navigate('players')"><span>Players</span></div>
        <div id="navPairing" class="nav-item disabled" onclick="navigate('pairing')"><span>Pairing</span></div>
        <div id="navResults" class="nav-item disabled" onclick="navigate('results')"><span>Game Result</span></div>
        <div id="navVisualization" class="nav-item disabled" onclick="navigate('visualization')"><span>Visualization</span></div>
        <div class="version">v0.1 SPA</div>
    </aside>
    <main class="main">
        <div id="sectionPlayers" class="section-view">
            <h2>Players</h2>
            <div class="actions">
                <button class="primary" onclick="triggerLoadPlayers()">Load Players (CSV/JSON)</button>
                <button onclick="openPlayerModal()">Add New Player</button>
                <button onclick="downloadPlayersCSV()">Download Players as CSV</button>
                <input id="playersFileInput" type="file" accept=".csv,.json" class="hidden" onchange="handlePlayersFile(event)" />
            </div>
            <div id="playersTableWrapper"></div>
        </div>

        <div id="sectionPairing" class="section-view hidden">
            <h2>Pairing</h2>
            <div class="actions">
                <button onclick="generatePairings()" class="primary">Generate Pairings</button>
                <button onclick="clearManualPairings()" class="danger">Clear All Manual Pairings</button>
                <button onclick="triggerLoadManualPairings()">Load Manual Pairings</button>
                <button onclick="downloadManualPairings()">Download Manual Pairings</button>
                <button onclick="downloadPairingsDetailed()">Download Detailed CSV</button>
                <button onclick="downloadPairingsPublic()">Download Public CSV</button>
                <input id="manualPairingsFileInput" type="file" accept=".json" class="hidden" onchange="handleManualPairingsFile(event)" />
            </div>

            <!-- Pairing Algorithm Configuration -->
            <div style="background:#f8f9fa; border:1px solid var(--border); padding:12px; border-radius:var(--radius); margin-bottom:20px;">
                <h3 style="margin:0 0 12px; font-size:.9rem; color:#666;">Pairing Algorithm Settings</h3>
                <div class="algorithm-settings" style="display:flex; gap:20px; align-items:center; flex-wrap:wrap;">
                    <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                        <input type="checkbox" id="categoryOnlyPairing">
                        <span>Category-only pairing</span>
                    </label>
                    <label style="display:flex; align-items:center; gap:6px; cursor:pointer;">
                        <input type="checkbox" id="ratingBasedPairing" checked>
                        <span>Rating-based pairing</span>
                    </label>
                    <div style="display:flex; align-items:center; gap:8px;">
                        <label for="ratingRange">Rating range (±):</label>
                        <input type="number" id="ratingRange" min="0" max="500" step="25" value="100" style="width:80px;">
                        <span style="font-size:0.85em; color:#666;">points</span>
                    </div>
                </div>
                <div style="margin-top:8px; font-size:0.8em; color:#666;">
                    <strong>Category-only:</strong> Pair players within same categories only (Advanced↔Intermediate↔Beginner as fallback)<br>
                    <strong>Rating-based:</strong> Pair by closest ratings within range. <strong>Random:</strong> Uncheck rating-based for random pairing.
                </div>
            </div>

            <div style="margin-bottom:14px;">
                <div style="background:#fff; border:1px solid var(--border); padding:12px; border-radius:var(--radius); margin-bottom:20px;">
                    <h3 style="margin:0 0 8px; font-size:.9rem;">Manual Pairing</h3>
                    <div class="manual-pairing-form" style="display:flex; gap:12px; align-items:flex-end; max-width:900px;">
                        <div style="flex:0 0 120px;">
                            <label>Table # (optional)</label>
                            <input type="number" id="manualTableInput" min="1" placeholder="Auto" />
                        </div>
                        <div style="flex:0 0 220px;">
                            <label>Player 1</label>
                            <select id="manualPlayer1"></select>
                        </div>
                        <div style="flex:0 0 220px;">
                            <label>Player 2</label>
                            <select id="manualPlayer2"></select>
                        </div>
                        <div style="flex:0 0 auto;">
                            <button onclick="addManualPairing()">Add Manual Pair</button>
                        </div>
                    </div>
                    <div class="divider"></div>
                    <div id="manualPairsList" class="scroll-y" style="font-size:.75rem;"></div>
                </div>

                <h3 style="margin:0 0 6px; font-size:.9rem;">Detailed Pairings</h3>
                <div id="pairingsDetailedWrapper" class="table-wrapper" style="margin-bottom:20px;"></div>

                <h3 style="margin:0 0 6px; font-size:.9rem;">Public Print Table</h3>
                <div id="pairingsPublicWrapper" class="table-wrapper" style="margin-bottom:20px;"></div>

                <h3 style="margin:0 0 6px; font-size:.9rem;">Absent Players</h3>
                <div id="absentPlayersWrapper" class="table-wrapper"></div>
            </div>
        </div>

        <div id="sectionResults" class="section-view hidden">
            <h2>Game Results</h2>
            <div class="actions">
                <button onclick="openResultModal()">Add Result</button>
                <button onclick="recalculateRatings()" class="primary">Recalculate Ratings</button>
                <button onclick="openPlayerReportModal()">Generate Report</button>
                <button onclick="triggerLoadGameResults()">Load Game Results</button>
                <button onclick="downloadGameResults()">Download Game Results</button>
                <button onclick="downloadPlayersCSV()">Download Updated Players (CSV)</button>
                <button onclick="downloadPlayersJSON()">Download Updated Players (JSON)</button>
                <input id="gameResultsFileInput" type="file" accept=".json" class="hidden" onchange="handleGameResultsFile(event)" />
            </div>
            <div style="margin-bottom:16px;">
                <label for="resultsFilter" style="display:block; font-size:.8rem; font-weight:600; margin-bottom:4px;">Filter by Player Name:</label>
                <input type="text" id="resultsFilter" placeholder="Type to filter results (supports wildcards * and ?)"
                       style="width:100%; max-width:500px; padding:8px 10px; border:1px solid var(--border); border-radius:var(--radius); font-size:.85rem;"
                       oninput="filterResults(this.value)" />
            </div>
            <div id="resultsTableWrapper"></div>
        </div>

        <div id="sectionVisualization" class="section-view hidden">
            <h2>Visualization</h2>
            <div class="actions">
                <label for="visualizationPlayerSelect" style="font-size:.85rem; font-weight:600; margin-right:8px;">Select Player:</label>
                <select id="visualizationPlayerSelect" onchange="showPlayerVisualization()" style="padding:8px 12px; border:1px solid var(--border); border-radius:var(--radius); font-size:.85rem; min-width:250px;">
                    <option value="">-- Select a player --</option>
                </select>
            </div>
            <div id="playerStatisticsWrapper" style="margin-top:20px;"></div>
            <div id="ratingChartWrapper" style="margin-top:30px;">
                <canvas id="ratingChart" style="max-width:900px; max-height:400px;"></canvas>
            </div>
        </div>
    </main>

    <!-- Modal root -->
    <div id="modalRoot"></div>

    <script>
        /******************************
         * Global State
         ******************************/
        let players = []; // {id, name, category, rating, presence, teacher, grade}
        let manualPairings = []; // {tableNumber|null, p1Id|null, p2Id|null, isManual:true}
        let autoPairings = []; // same shape but isManual:false
        let results = []; // {id, p1Id, p2Id, outcome: 'P1'|'P2'|'DRAW'}
        let nextPlayerId = 1;
        let nextResultId = 1;

        const CATEGORY_VALUES = ['Advanced','Intermediate','Beginner'];
        const CSV_HEADERS = ['player id','name','category','rates','presence','teacher name','class'];

        /******************************
         * Navigation
         ******************************/
        function capitalize(s){return s.charAt(0).toUpperCase()+s.slice(1);}
        function updateNavEnablement(){
            const enable = players.length >= 2;
            ['navPairing','navResults','navVisualization'].forEach(id => {
                const el = document.getElementById(id);
                if (enable) el.classList.remove('disabled'); else el.classList.add('disabled');
            });
        }

        /******************************
         * Players Section
         ******************************/
        function triggerLoadPlayers(){
            document.getElementById('playersFileInput').click();
        }
        function handlePlayersFile(e){
            const file = e.target.files[0];
            if(!file){return;}
                // Reset full tournament state before loading new players
                resetTournamentState();
                const reader = new FileReader();
                reader.onload = evt => {
                    const text = evt.target.result.trim();
                    // Detect JSON vs CSV by file extension or content
                    if(file.name.endsWith('.json') || text.startsWith('{')){
                        importPlayersFromJSON(text);
                    } else {
                        importPlayersFromCSV(text);
                    }
                    // allow selecting same file again
                    e.target.value = '';
                };
                reader.readAsText(file);
        }
            function resetTournamentState(){
                players = [];
                manualPairings = [];
                autoPairings = [];
                results = [];
                nextPlayerId = 1;
                nextResultId = 1;
                document.getElementById('manualPairsList').innerHTML='';
                document.getElementById('pairingsDetailedWrapper').innerHTML='';
                document.getElementById('pairingsPublicWrapper').innerHTML='';
                document.getElementById('resultsTableWrapper').innerHTML='';
            }
        function importPlayersFromCSV(text){
            const lines = text.split(/\r?\n/).filter(l=>l.trim().length>0);
            if(lines.length<2){alert('CSV has no data');return;}
            const header = lines[0].split(',').map(h=>h.trim().toLowerCase());
            const missing = CSV_HEADERS.filter(h=>!header.includes(h));
            if(missing.length){alert('Missing headers: '+missing.join(', '));}
            const idx = h=> header.indexOf(h);
            lines.slice(1).forEach(line=>{
                const parts = line.split(',').map(v=>v.trim());
                if(parts.every(p=>!p)) return;
                const rawId = parts[idx('player id')];
                const id = rawId? parseInt(rawId) : nextPlayerId++;
                if(id >= nextPlayerId) nextPlayerId = id+1;
                const name = parts[idx('name')] || 'Unnamed';
                let category = parts[idx('category')] || 'Beginner';
                // Case-insensitive category validation / normalization
                const catLower = category.toLowerCase();
                const matched = CATEGORY_VALUES.find(c => c.toLowerCase() === catLower);
                category = matched || 'Beginner';
                const rating = parseInt(parts[idx('rates')])||0;
                const presenceRaw = (parts[idx('presence')]||'').toLowerCase();
                const presence = !(presenceRaw==='n'||presenceRaw==='no'||presenceRaw==='not'||presenceRaw==='false');
                const teacher = parts[idx('teacher name')]||'';
                const grade = parts[idx('class')]||'';

                // Set initialRating based on category (CSV doesn't have initialRating field)
                const initialRating = category === 'Advanced' ? 1000 : category === 'Intermediate' ? 600 : 200;

                players.push({
                    id,
                    name,
                    category,
                    rating: rating || initialRating,
                    initialRating: initialRating,
                    presence,
                    teacher,
                    grade,
                    lastDelta: 0,
                    statistics: null,
                    history: []
                });
            });
            renderPlayersTable();
            updateNavEnablement();
        }
        function importPlayersFromJSON(text){
            try {
                const data = JSON.parse(text);
                // Support both direct array and {players: [...]} structure
                const playerArray = Array.isArray(data) ? data : data.players;
                if(!playerArray || !playerArray.length){
                    alert('JSON file has no players data');
                    return;
                }
                playerArray.forEach(p=>{
                    const id = p.id || nextPlayerId++;
                    if(id >= nextPlayerId) nextPlayerId = id+1;

                    const category = p.category || 'Beginner';
                    // Use initialRating from JSON if available, otherwise calculate from category
                    const defaultInitialRating = category === 'Advanced' ? 1000 : category === 'Intermediate' ? 600 : 200;
                    const initialRating = p.initialRating !== undefined ? p.initialRating : defaultInitialRating;

                    // Map JSON structure to internal player object
                    players.push({
                        id: id,
                        name: p.name || 'Unnamed',
                        category: category,
                        rating: p.currentRating || p.rating || initialRating,
                        initialRating: initialRating,  // Preserve from JSON or use default
                        presence: p.presence !== undefined ? p.presence : true,
                        teacher: p.teacher !== undefined ? String(p.teacher) : '',
                        grade: p.grade !== undefined ? String(p.grade) : '',
                        lastDelta: 0,
                        // Store statistics and history for later use
                        statistics: p.statistics || null,
                        history: p.history || []
                    });
                });
                renderPlayersTable();
                updateNavEnablement();
            } catch(e) {
                alert('Error parsing JSON file: ' + e.message);
            }
        }
        function renderPlayersTable(){
            const wrapper = document.getElementById('playersTableWrapper');
            if(!players.length){wrapper.innerHTML='<p class="muted">No players loaded. Use "Load Players" or add manually.</p>'; return;}
            let html = '<div class="table-wrapper"><table><thead><tr>'+
                '<th class="mobile-hide">ID</th><th>Name</th><th>Category</th><th>Rating</th><th>Presence</th><th class="mobile-hide">Teacher</th><th class="mobile-hide">Grade</th><th>Actions</th></tr></thead><tbody>';
            players.forEach(p=>{
                html+=`<tr>`+
                    `<td class="mobile-hide">${p.id}</td>`+
                    `<td>${escapeHtml(p.name)}</td>`+
                    `<td>${p.category}</td>`+
                            `<td>${p.rating}${p.lastDelta>0?`<span class=\"rate-up\" title=\"+${p.lastDelta}\">▲ (+${p.lastDelta})</span>`:p.lastDelta<0?`<span class=\"rate-down\" title=\"${p.lastDelta}\">▼ (${p.lastDelta})</span>`:''}</td>`+
                    `<td class="checkbox-center"><input type="checkbox" ${p.presence?'checked':''} onchange="togglePresence(${p.id},this.checked)" title="Toggle presence" /></td>`+
                    `<td class="mobile-hide">${escapeHtml(p.teacher)}</td>`+
                    `<td class="mobile-hide">${escapeHtml(p.grade)}</td>`+
                    `<td><button class="mini" onclick="openPlayerModal(${p.id})">Edit</button> <button class="mini danger" onclick="confirmDeletePlayer(${p.id})">Delete</button></td>`+
                `</tr>`;
            });
            html+='</tbody></table></div>';
            wrapper.innerHTML=html;
        }
        function togglePresence(id,val){
            const p=players.find(pl=>pl.id===id); if(!p) return; p.presence=val; }
        function openPlayerModal(id){
            const isEdit = !!id; const player = players.find(p=>p.id===id)||{};
            showModal({
                title: isEdit?`Edit Player #${player.id}`:'Add New Player',
                body: modalPlayerForm(player,isEdit),
                onConfirm: ()=>{
                    const form = document.getElementById('playerForm');
                    const name = form.name.value.trim();
                    const category = form.category.value;
                    const rating = parseInt(form.rating.value)||0;
                    const presence = form.presence.checked;
                    const teacher = form.teacher.value.trim();
                    const grade = form.grade.value.trim();
                    if(!name){alert('Name required');return false;}
                    if(isEdit){
                        // When editing, never change initialRating
                        player.name=name; player.category=category; player.rating=rating; player.presence=presence; player.teacher=teacher; player.grade=grade;
                    } else {
                        // When creating new player, set initialRating based on category
                        const initialRating = category === 'Advanced' ? 1000 : category === 'Intermediate' ? 600 : 200;
                        players.push({
                            id: nextPlayerId++,
                            name,
                            category,
                            rating: rating || initialRating,
                            initialRating: initialRating,
                            presence,
                            teacher,
                            grade,
                            lastDelta: 0,
                            statistics: null,
                            history: []
                        });
                    }
                    renderPlayersTable(); updateNavEnablement(); return true;
                }
            });
        }
        function modalPlayerForm(p,isEdit){
            return `<form id="playerForm">`+
                `<label>Name</label><input name="name" type="text" value="${p.name||''}" required />`+
                `<label>Category</label><select name="category">${CATEGORY_VALUES.map(c=>`<option ${p.category===c?'selected':''}>${c}</option>`).join('')}</select>`+
                `<label>Rating</label><input name="rating" type="number" min="0" value="${p.rating||0}" />`+
                `<label>Present for next game</label><input name="presence" type="checkbox" ${p.presence||!isEdit?'checked':''} />`+
                `<label>Teacher's Name</label><input name="teacher" type="text" value="${p.teacher||''}" />`+
                `<label>Grade</label><input name="grade" type="text" value="${p.grade||''}" />`+
                `</form>`;
        }
        function confirmDeletePlayer(id){
            const p = players.find(pl=>pl.id===id); if(!p) return;
            showModal({
                title:'Remove Player',
                body:`<p>Are you sure you want to remove player <strong>${escapeHtml(p.name)}</strong> from the list?</p>`,
                confirmText:'Delete',
                confirmClass:'danger',
                onConfirm:()=>{ players = players.filter(pl=>pl.id!==id); renderPlayersTable(); updateNavEnablement(); return true; }
            });
        }
        function downloadPlayersCSV(){
            let csv = CSV_HEADERS.join(',')+'\n';
            players.forEach(p=>{
                csv += `${p.id},${p.name||''},${p.category},${p.rating},${p.presence?'yes':'no'},${p.teacher||''},${p.grade||''}\n`;
            });
            triggerDownload(csv,'players.csv');
        }
        function csvEscape(s){ return '"'+(s||'').replace(/"/g,'""')+'"'; }

        /******************************
         * Pairing Logic
         ******************************/
        function refreshPairingSelectors(){
            const sel1 = document.getElementById('manualPlayer1');
            const sel2 = document.getElementById('manualPlayer2');
            [sel1,sel2].forEach(sel=>{ sel.innerHTML=''; });
            const noOpt = document.createElement('option'); noOpt.value='NO_PARTNER'; noOpt.textContent='(No partner)';
            sel1.appendChild(noOpt.cloneNode(true)); sel2.appendChild(noOpt.cloneNode(true));
            players.filter(p=>p.presence).forEach(p=>{
                const opt=document.createElement('option'); opt.value=p.id; opt.textContent=`#${p.id} - ${p.name} (${p.category}, ${p.rating})`; sel1.appendChild(opt.cloneNode(true)); sel2.appendChild(opt); });
        }
        function addManualPairing(){
            const tableRaw = document.getElementById('manualTableInput').value.trim();
            const p1Val = document.getElementById('manualPlayer1').value;
            const p2Val = document.getElementById('manualPlayer2').value;
            if(!p1Val || !p2Val){ alert('Select both players (or No partner)'); return; }
            if(p1Val===p2Val && p1Val!=='NO_PARTNER'){ alert('Cannot pair player with themselves'); return; }
            const p1Id = p1Val==='NO_PARTNER'? null : parseInt(p1Val);
            const p2Id = p2Val==='NO_PARTNER'? null : parseInt(p2Val);
            // Prevent pair of two "No partner" placeholders
            if(p1Id===null && p2Id===null){
                alert('Cannot create a pair with two "No partner" entries. Select at least one real player.');
                return;
            }
            // prevent duplicate involvement (ignore null placeholder so '(No partner)' can be reused)
            const already = manualPairings.find(mp =>
                (p1Id !== null && (mp.p1Id === p1Id || mp.p2Id === p1Id)) ||
                (p2Id !== null && (mp.p1Id === p2Id || mp.p2Id === p2Id))
            );
            if(already){ alert('One selected player already in a manual pairing'); return; }
            let tableNumber = tableRaw? parseInt(tableRaw): null;
            if(tableNumber && manualPairings.some(mp=>mp.tableNumber===tableNumber)) { alert('Table number already used by manual pairing'); return; }
            manualPairings.push({tableNumber,p1Id,p2Id,isManual:true,isAutoTable:!tableNumber});
                // Reset inputs for next quick entry
                const tableInput = document.getElementById('manualTableInput');
                const sel1 = document.getElementById('manualPlayer1');
                const sel2 = document.getElementById('manualPlayer2');
                tableInput.value='';
                sel1.value='NO_PARTNER';
                sel2.value='NO_PARTNER';
                sel1.focus();
            renderManualPairsList();
            generatePairings();
        }
        function renderManualPairsList(){
            const box = document.getElementById('manualPairsList');
            if(!manualPairings.length){ box.innerHTML='<p class="muted">No manual pairings.</p>'; return; }
            let html='';
            manualPairings.forEach((mp,i)=>{
                const p1 = mp.p1Id? players.find(p=>p.id===mp.p1Id): null;
                const p2 = mp.p2Id? players.find(p=>p.id===mp.p2Id): null;
                const label1 = p1? `#${p1.id} - ${escapeHtml(p1.name)} (${p1.rating})`:'<span class="no-partner">(No partner)</span>';
                const label2 = p2? `#${p2.id} - ${escapeHtml(p2.name)} (${p2.rating})`:'<span class="no-partner">(No partner)</span>';

                // Display table info
                let tableDisplay;
                if(mp.isAutoTable) {
                    tableDisplay = mp.assignedTableNumber ? `Auto table (${mp.assignedTableNumber})` : 'Auto table';
                } else {
                    tableDisplay = `Table ${mp.tableNumber}`;
                }

                html += `<div class="manual-pair-container" style="margin-bottom:6px; border:1px solid var(--border); padding:8px; border-radius:4px; background:#fff; max-width:946px;">`+
                    `<div class="manual-pair-item" style="display:flex; gap:12px; align-items:center; justify-content:space-between;">`+
                    `<div class="manual-pair-info" style="display:flex; gap:12px; align-items:center;">`+
                    `<div style="flex:0 0 150px; font-weight:bold;">${tableDisplay}</div>`+
                    `<div style="flex:0 0 auto;">${label1}</div>`+
                    `<div style="flex:0 0 20px; text-align:center; color:#666;">vs</div>`+
                    `<div style="flex:0 0 auto;">${label2}</div>`+
                    `</div>`+
                    `<div class="manual-pair-controls" style="display:flex; gap:8px; align-items:center;">`+
                    `<span class="tag manual">MANUAL</span>`+
                    `<button class="mini" onclick="editManualPair(${i})">Edit</button>`+
                    `<button class="mini danger" onclick="deleteManualPair(${i})">Delete</button>`+
                    `</div>`+
                    `</div></div>`;
            });
            box.innerHTML=html;
        }
        function editManualPair(i){
            const mp = manualPairings[i];
            if(!mp) return;

            // Populate the form fields with current values
            const tableInput = document.getElementById('manualTableInput');
            const sel1 = document.getElementById('manualPlayer1');
            const sel2 = document.getElementById('manualPlayer2');

            tableInput.value = mp.isAutoTable ? '' : (mp.tableNumber || '');
            sel1.value = mp.p1Id !== null ? mp.p1Id.toString() : 'NO_PARTNER';
            sel2.value = mp.p2Id !== null ? mp.p2Id.toString() : 'NO_PARTNER';

            // Delete the old entry
            manualPairings.splice(i, 1);
            renderManualPairsList();
            generatePairings();

            // Scroll to the form and focus the first field
            tableInput.focus();
            tableInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
        function deleteManualPair(i){ manualPairings.splice(i,1); renderManualPairsList(); generatePairings(); }
        function clearManualPairings(){ if(!manualPairings.length) return; if(!confirm('Clear all manual pairings?')) return; manualPairings = []; renderManualPairsList(); generatePairings(); }
        function generatePairings(){
            // Get algorithm settings
            const categoryOnly = document.getElementById('categoryOnlyPairing').checked;
            const ratingBased = document.getElementById('ratingBasedPairing').checked;
            const ratingRange = parseInt(document.getElementById('ratingRange').value) || 100;

            // Build set of player IDs already manually paired
            const used = new Set();
            manualPairings.forEach(mp=>{ if(mp.p1Id) used.add(mp.p1Id); if(mp.p2Id) used.add(mp.p2Id); });
            const available = players.filter(p=>p.presence && !used.has(p.id));
            const alreadyPaired = new Set();
            autoPairings = [];

            // Helper function to add pairing and track paired players
            function addPairing(p1, p2) {
                autoPairings.push({tableNumber:null,p1Id:p1?.id||null,p2Id:p2?.id||null,isManual:false});
                if(p1) alreadyPaired.add(p1.id);
                if(p2) alreadyPaired.add(p2.id);
            }

            // Helper to find best partner for a player
            function findPartner(player, candidates) {
                const unpaired = candidates.filter(c => !alreadyPaired.has(c.id) && c.id !== player.id);
                if(!unpaired.length) return null;

                if(!ratingBased) {
                    // Random pairing
                    return unpaired[Math.floor(Math.random() * unpaired.length)];
                }

                // Rating-based pairing
                const inRange = unpaired.filter(c => Math.abs(c.rating - player.rating) <= ratingRange);
                if(inRange.length) {
                    // Random pick from players within rating range
                    return inRange[Math.floor(Math.random() * inRange.length)];
                } else {
                    // Find closest rating if no one in range
                    return unpaired.reduce((closest, current) =>
                        Math.abs(current.rating - player.rating) < Math.abs(closest.rating - player.rating)
                            ? current : closest
                    );
                }
            }

            if(categoryOnly) {
                // Category-only pairing
                const groups = {Advanced:[],Intermediate:[],Beginner:[]};
                available.forEach(p=>groups[p.category].push(p));

                // Process each category individually: pair within category, then handle leftover immediately
                const categoryOrder = ['Advanced', 'Intermediate', 'Beginner'];

                categoryOrder.forEach((categoryName) => {
                    const group = groups[categoryName];
                    if(!group.length) return;

                    // Pair within this category
                    while(group.length >= 2) {
                        const unpaired = group.filter(p => !alreadyPaired.has(p.id));
                        if(unpaired.length < 2) break;

                        const player1 = unpaired[0];
                        const player2 = findPartner(player1, unpaired);
                        if(player2) {
                            addPairing(player1, player2);
                        } else {
                            break;
                        }
                    }

                    // Handle leftover from this category immediately with "(No partner)"
                    const leftover = group.filter(p => !alreadyPaired.has(p.id))[0];
                    if(leftover) {
                        addPairing(leftover, null); // Pair with "(No partner)"
                    }
                });

            } else {
                // Cross-category pairing allowed
                while(available.length >= 2) {
                    const unpaired = available.filter(p => !alreadyPaired.has(p.id));
                    if(unpaired.length < 2) break;

                    const player1 = unpaired[0];
                    const player2 = findPartner(player1, unpaired);
                    if(player2) {
                        addPairing(player1, player2);
                    } else {
                        break;
                    }
                }
            }

            // Pair any remaining single players with "(No partner)"
            const remaining = available.filter(p => !alreadyPaired.has(p.id));
            remaining.forEach(p => addPairing(p, null));

            assignTableNumbers();
            renderManualPairsList();
            renderPairingsTables();
        }
        function assignTableNumbers(){
            // Backward compatibility: add isAutoTable flag for existing pairings without it
            manualPairings.forEach(mp => {
                if(mp.isAutoTable === undefined) {
                    mp.isAutoTable = !mp.tableNumber;
                }
            });

            // Preserve manual table numbers; allocate sequential for others
            const taken = new Set(manualPairings.filter(mp=>mp.tableNumber && !mp.isAutoTable).map(mp=>mp.tableNumber));
            let next=1;
            function nextFree(){ while(taken.has(next)) next++; return next++; }

            // Reset assigned numbers for auto table manual pairings
            manualPairings.forEach(mp=>{
                if(mp.isAutoTable) {
                    mp.assignedTableNumber = nextFree();
                }
            });
            autoPairings.forEach(ap=>{ ap.tableNumber=nextFree(); });
        }
        function renderPairingsTables(){
            // Merge lists with proper table numbers for sorting
            const combined = [...manualPairings.map(mp => ({
                ...mp,
                displayTableNumber: mp.isAutoTable ? mp.assignedTableNumber : mp.tableNumber,
                sortTableNumber: mp.isAutoTable ? mp.assignedTableNumber : mp.tableNumber
            })), ...autoPairings].sort((a,b)=> (a.sortTableNumber || a.tableNumber) - (b.sortTableNumber || b.tableNumber));
            // Detailed
            const detailedWrapper = document.getElementById('pairingsDetailedWrapper');
            if(!combined.length){ detailedWrapper.innerHTML='<p class="muted">No pairings yet. Use Generate Pairings.</p>'; return; }
            let html = '<table><thead><tr><th>Table</th><th>Player 1</th><th class="mobile-hide">Cat</th><th class="mobile-hide">Rating</th><th>Player 2</th><th class="mobile-hide">Cat</th><th class="mobile-hide">Rating</th><th>Type</th></tr></thead><tbody>';
            combined.forEach(p=>{
                const p1 = p.p1Id? players.find(pl=>pl.id===p.p1Id): null;
                const p2 = p.p2Id? players.find(pl=>pl.id===p.p2Id): null;
                html += `<tr>`+
                    `<td>${p.displayTableNumber || p.tableNumber}</td>`+
                    `<td>${p1? `#${p1.id} - ${escapeHtml(p1.name)}`: '<span class="no-partner">(No partner)</span>'}</td>`+
                    `<td class="mobile-hide">${p1? p1.category:''}</td>`+
                    `<td class="mobile-hide">${p1? p1.rating:''}</td>`+
                    `<td>${p2? `#${p2.id} - ${escapeHtml(p2.name)}`: '<span class="no-partner">(No partner)</span>'}</td>`+
                    `<td class="mobile-hide">${p2? p2.category:''}</td>`+
                    `<td class="mobile-hide">${p2? p2.rating:''}</td>`+
                    `<td><span class="tag ${p.isManual?'manual':'auto'}">${p.isManual?'MANUAL':'AUTO'}</span></td>`+
                `</tr>`;
            });
            html += '</tbody></table>';
            detailedWrapper.innerHTML=html;
            // Public
            const publicWrapper=document.getElementById('pairingsPublicWrapper');
            let pub='<table><thead><tr><th>Table</th><th>Match White vs Black</th></tr></thead><tbody>';
            combined.forEach(p=>{
                const p1 = p.p1Id? players.find(pl=>pl.id===p.p1Id): null;
                const p2 = p.p2Id? players.find(pl=>pl.id===p.p2Id): null;
                const nameFmt = pl => pl? shortPublicName(pl.name): '(No partner)';
                pub += `<tr><td>${p.displayTableNumber || p.tableNumber}:</td><td>${nameFmt(p1)} vs ${nameFmt(p2)}</td></tr>`;
            });
            pub+='</tbody></table>';
            publicWrapper.innerHTML=pub;
            // Absent Players
            renderAbsentPlayersTable();
        }

        function renderAbsentPlayersTable(){
            const absentWrapper = document.getElementById('absentPlayersWrapper');
            const absentPlayers = players.filter(p => !p.presence);

            if(!absentPlayers.length){
                absentWrapper.innerHTML='<p class="muted">All players are present for this round.</p>';
                return;
            }

            let html = '<table><thead><tr><th class="mobile-hide">ID</th><th>Name</th><th>Category</th><th class="mobile-hide">Rating</th><th class="mobile-hide">Teacher</th><th class="mobile-hide">Grade</th></tr></thead><tbody>';
            absentPlayers.forEach(p=>{
                html += `<tr style="opacity: 0.7;">`+
                    `<td class="mobile-hide">${p.id}</td>`+
                    `<td>#${p.id} - ${escapeHtml(p.name)}</td>`+
                    `<td>${p.category}</td>`+
                    `<td class="mobile-hide">${p.rating}</td>`+
                    `<td class="mobile-hide">${escapeHtml(p.teacher)}</td>`+
                    `<td class="mobile-hide">${escapeHtml(p.grade)}</td>`+
                `</tr>`;
            });
            html += '</tbody></table>';
            absentWrapper.innerHTML = html;
        }
        function shortPublicName(full){ const parts=full.split(' '); return parts[0] + (parts[1]? ' '+parts[1][0]+'.':''); }

        function downloadPairingsDetailed(){
            const combined=[...manualPairings,...autoPairings].sort((a,b)=>a.tableNumber-b.tableNumber);
            let csv='Table,Player1,Cat1,Rating1,Player2,Cat2,Rating2,Type\n';
            combined.forEach(p=>{
                const p1 = p.p1Id? players.find(pl=>pl.id===p.p1Id): null;
                const p2 = p.p2Id? players.find(pl=>pl.id===p.p2Id): null;
                csv += `${p.tableNumber},${p1?p1.name:''},${p1?p1.category:''},${p1?p1.rating:''},${p2?p2.name:''},${p2?p2.category:''},${p2?p2.rating:''},${p.isManual?'MANUAL':'AUTO'}\n`;
            });
            triggerDownload(csv,'pairings_detailed.csv');
        }
        function downloadPairingsPublic(){
            const combined=[...manualPairings,...autoPairings].sort((a,b)=>a.tableNumber-b.tableNumber);
            let csv='Table,Match\n';
            combined.forEach(p=>{
                const p1 = p.p1Id? players.find(pl=>pl.id===p.p1Id): null;
                const p2 = p.p2Id? players.find(pl=>pl.id===p.p2Id): null;
                const nameFmt = pl => pl? shortPublicName(pl.name): '(No partner)';
                csv += `${p.tableNumber},${nameFmt(p1)} vs ${nameFmt(p2)}\n`;
            });
            triggerDownload(csv,'pairings_public.csv');
        }

        // Manual Pairings Load/Save Functions
        function triggerLoadManualPairings(){
            document.getElementById('manualPairingsFileInput').click();
        }

        function handleManualPairingsFile(e){
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = evt => {
                try {
                    const data = JSON.parse(evt.target.result);
                    if(!Array.isArray(data)) {
                        alert('Invalid manual pairings file format');
                        return;
                    }
                    // Validate data structure
                    const isValid = data.every(mp =>
                        typeof mp.isManual === 'boolean' &&
                        (mp.p1Id === null || typeof mp.p1Id === 'number') &&
                        (mp.p2Id === null || typeof mp.p2Id === 'number') &&
                        (mp.tableNumber === null || typeof mp.tableNumber === 'number')
                    );
                    if(!isValid) {
                        alert('Invalid manual pairings data structure');
                        return;
                    }

                    // Check if referenced players exist
                    const playerIds = new Set(players.map(p => p.id));
                    const missingPlayers = data.filter(mp =>
                        (mp.p1Id !== null && !playerIds.has(mp.p1Id)) ||
                        (mp.p2Id !== null && !playerIds.has(mp.p2Id))
                    );
                    if(missingPlayers.length > 0) {
                        if(!confirm(`Some players in the pairings file don't exist in current players list. Load anyway? (Missing players will be skipped)`)) {
                            return;
                        }
                        // Filter out pairings with missing players
                        manualPairings = data.filter(mp =>
                            (mp.p1Id === null || playerIds.has(mp.p1Id)) &&
                            (mp.p2Id === null || playerIds.has(mp.p2Id))
                        );
                    } else {
                        manualPairings = data;
                    }

                    renderManualPairsList();
                    generatePairings();
                    alert('Manual pairings loaded successfully');
                } catch(err) {
                    alert('Error reading manual pairings file: ' + err.message);
                }
                e.target.value = ''; // Allow selecting same file again
            };
            reader.readAsText(file);
        }

        function downloadManualPairings(){
            if(!manualPairings.length) {
                alert('No manual pairings to download');
                return;
            }
            const data = JSON.stringify(manualPairings, null, 2);
            triggerDownload(data, 'manual_pairings.json');
        }

        /******************************
         * Results Section
         ******************************/
        function renderResultsTable(filterText = ''){
            const wrapper = document.getElementById('resultsTableWrapper');
            if(!results.length){ wrapper.innerHTML='<p class="muted">No results recorded yet.</p>'; return; }

            // Filter results by player names
            let filteredResults = results;
            if(filterText.trim()) {
                const pattern = wildcardToRegex(filterText.trim());
                filteredResults = results.filter(r => {
                    const p1 = players.find(p=>p.id===r.p1Id);
                    const p2 = players.find(p=>p.id===r.p2Id);
                    const p1Name = p1 ? p1.name.toLowerCase() : '';
                    const p2Name = p2 ? p2.name.toLowerCase() : '';
                    return pattern.test(p1Name) || pattern.test(p2Name);
                });
            }

            if(!filteredResults.length){
                wrapper.innerHTML='<p class="muted">No results match the filter.</p>';
                return;
            }

            let html='<table><thead><tr><th class="mobile-hide">ID</th><th>Player 1</th><th>Player 2</th><th>Outcome</th><th class="mobile-hide">Status</th><th>Actions</th></tr></thead><tbody>';
            filteredResults.forEach(r=>{
                const p1 = players.find(p=>p.id===r.p1Id); const p2 = players.find(p=>p.id===r.p2Id);
                    const d1 = r.applied ? (typeof r.deltaP1==='number'? r.deltaP1 : 0) : 0;
                    const d2 = r.applied ? (typeof r.deltaP2==='number'? r.deltaP2 : 0) : 0;
                    const fmtPlayer = (pl,delta) => {
                        if(!pl) return '?';
                        const base = `#${pl.id} - ${escapeHtml(pl.name)} (${pl.rating}`;
                        if(!r.applied) return base + ')';
                        if(delta>0) return base + `) <span class=\"rate-up\" title=\"+${delta}\">▲ (+${delta})</span>`;
                        if(delta<0) return base + `) <span class=\"rate-down\" title=\"${delta}\">▼ (${delta})</span>`;
                        return base + ')';
                    };
                    html += `<tr>`+
                        `<td class="mobile-hide">${r.id}:</td>`+
                        `<td>${fmtPlayer(p1,d1)}</td>`+
                        `<td>${fmtPlayer(p2,d2)}</td>`+
                        `<td>${r.outcome==='P1'? 'P1 wins': r.outcome==='P2'? 'P2 wins':'Draw'}</td>`+
                        `<td class="mobile-hide">${r.applied?'<span class=\"tag applied\" title=\"Ratings updated from this result\">APPLIED</span>':'<span class=\"tag auto\" title=\"Pending rating update\">PENDING</span>'}</td>`+
                        `<td>${r.applied?`<button class=\"mini danger\" onclick=\"deleteResult(${r.id})\">Delete</button>`:`<button class=\"mini\" onclick=\"editResult(${r.id})\">Edit</button> <button class=\"mini danger\" onclick=\"deleteResult(${r.id})\">Delete</button>`}</td>`+
                    `</tr>`;
            });
            html+='</tbody></table>';
            wrapper.innerHTML=html;
        }

        function filterResults(filterText) {
            renderResultsTable(filterText);
        }

        function wildcardToRegex(pattern) {
            // Escape special regex characters except * and ?
            const escaped = pattern.replace(/[.+^${}()|[\]\\]/g, '\\$&');
            // Convert wildcards: * matches any characters, ? matches single character
            const regexPattern = escaped.replace(/\*/g, '.*').replace(/\?/g, '.');
            return new RegExp(regexPattern, 'i'); // case-insensitive
        }

        function openResultModal(){
            if(players.length<2){ alert('Need at least 2 players'); return; }
            showModal({
                title:'Add Result',
                body: resultForm(),
                onConfirm: ()=>{
                    const f=document.getElementById('resultForm');
                    const p1=parseInt(f.p1.value); const p2=parseInt(f.p2.value); const outcome=f.outcome.value;
                    if(p1===p2){ alert('Players must differ'); return false; }
                    results.push({id: nextResultId++, p1Id:p1, p2Id:p2, outcome, applied:false, deltaP1:0, deltaP2:0});
                    renderResultsTable(); return true;
                }
            });
        }
        function resultForm(r={}){
            const playerOptions = players.map(p=> `<option value="${p.id}" ${r.p1Id===p.id?'selected':''}>#${p.id} - ${escapeHtml(p.name)} (${p.category}, ${p.rating})</option>`).join('');
            const playerOptions2 = players.map(p=> `<option value="${p.id}" ${r.p2Id===p.id?'selected':''}>#${p.id} - ${escapeHtml(p.name)} (${p.category}, ${p.rating})</option>`).join('');
            return `<form id="resultForm">`+
                `<label>Player 1</label><select name="p1">${playerOptions}</select>`+
                `<label>Player 2</label><select name="p2">${playerOptions2}</select>`+
                `<label>Outcome</label><select name="outcome">`+
                    `<option value="P1" ${r.outcome==='P1'?'selected':''}>Player 1 wins</option>`+
                    `<option value="P2" ${r.outcome==='P2'?'selected':''}>Player 2 wins</option>`+
                    `<option value="DRAW" ${r.outcome==='DRAW'?'selected':''}>Draw</option>`+
                `</select>`+
            `</form>`;
        }
        function editResult(id){
            const r=results.find(res=>res.id===id); if(!r) return;
            showModal({
                title:`Edit Result #${id}`,
                body: resultForm(r),
                onConfirm:()=>{
                        if(r.applied){ alert('Applied results cannot be edited. Delete and add a new result instead.'); return false; }
                    const f=document.getElementById('resultForm');
                    const p1=parseInt(f.p1.value); const p2=parseInt(f.p2.value); const outcome=f.outcome.value;
                    if(p1===p2){ alert('Players must differ'); return false; }
                    r.p1Id=p1; r.p2Id=p2; r.outcome=outcome; renderResultsTable(); return true;
                }
            });
        }
        function deleteResult(id){
            showModal({
                title:'Delete Result',
                body:'Are you sure you want to delete this result?',
                confirmText:'Delete', confirmClass:'danger',
                onConfirm:()=>{ results = results.filter(r=>r.id!==id); renderResultsTable(); return true; }
            });
        }
        function recalculateRatings(){
                const pending = results.filter(r=>!r.applied);
                if(!pending.length){ alert('No pending results to apply.'); return; }

                // Store original ratings to calculate total deltas
                const originalRatings = new Map();
                players.forEach(p => {
                    originalRatings.set(p.id, p.rating);
                });

                // Process games sequentially, updating ratings after each game
                pending.forEach(r=>{
                    const p1 = players.find(p=>p.id===r.p1Id);
                    const p2 = players.find(p=>p.id===r.p2Id);
                    if(!p1||!p2) return;

                    // Use current ratings (which may have been updated by previous games)
                    const before1 = p1.rating;
                    const before2 = p2.rating;
                    const expected1 = 1/(1+Math.pow(10,(p2.rating - p1.rating)/400));
                    const expected2 = 1/(1+Math.pow(10,(p1.rating - p2.rating)/400));

                    let score1, score2;
                    if(r.outcome==='P1'){ score1=1; score2=0; }
                    else if(r.outcome==='P2'){ score1=0; score2=1; }
                    else { score1=0.5; score2=0.5; }

                    const k=32;
                    const new1 = Math.max(0, Math.round(p1.rating + k*(score1-expected1)));
                    const new2 = Math.max(0, Math.round(p2.rating + k*(score2-expected2)));

                    // Update player ratings immediately for next calculation
                    p1.rating = new1;
                    p2.rating = new2;

                    // Store individual game deltas
                    r.deltaP1 = new1 - before1;
                    r.deltaP2 = new2 - before2;
                    r.applied = true;
                });

                // Calculate total deltas from original ratings and update lastDelta for display
                players.forEach(p => {
                    const originalRating = originalRatings.get(p.id);
                    if (originalRating !== undefined) {
                        p.lastDelta = p.rating - originalRating;
                    }

                    // Update player statistics in memory
                    p.statistics = calculatePlayerStatistics(p.id);
                });

                renderPlayersTable();
                renderResultsTable();
                alert('Applied '+pending.length+' result(s). Ratings updated.');
        }

        // Game Results Load/Save Functions
        function triggerLoadGameResults(){
            document.getElementById('gameResultsFileInput').click();
        }

        function handleGameResultsFile(e){
            const file = e.target.files[0];
            if(!file) return;

            // Check if there are existing results
            if(results.length > 0) {
                showModal({
                    title: 'Load Game Results',
                    body: `<p>You have ${results.length} existing game result(s).</p><p>How would you like to load the new results?</p>`,
                    confirmText: 'Append',
                    cancelText: 'Override',
                    onConfirm: () => {
                        loadGameResultsFromFile(file, true); // true = append
                        return true;
                    },
                    onCancel: () => {
                        loadGameResultsFromFile(file, false); // false = override
                    }
                });
                e.target.value = ''; // Allow selecting same file again
                return;
            }

            // No existing results, just load
            loadGameResultsFromFile(file, false);
            e.target.value = ''; // Allow selecting same file again
        }

        function loadGameResultsFromFile(file, append) {
            const reader = new FileReader();
            reader.onload = evt => {
                try {
                    const data = JSON.parse(evt.target.result);
                    if(!Array.isArray(data)) {
                        alert('Invalid game results file format');
                        return;
                    }
                    // Validate data structure
                    const isValid = data.every(r =>
                        typeof r.id === 'number' &&
                        typeof r.p1Id === 'number' &&
                        typeof r.p2Id === 'number' &&
                        ['P1', 'P2', 'DRAW'].includes(r.outcome) &&
                        typeof r.applied === 'boolean'
                    );
                    if(!isValid) {
                        alert('Invalid game results data structure');
                        return;
                    }

                    // Check if referenced players exist
                    const playerIds = new Set(players.map(p => p.id));
                    const missingPlayers = data.filter(r =>
                        !playerIds.has(r.p1Id) || !playerIds.has(r.p2Id)
                    );

                    let validResults = data;
                    if(missingPlayers.length > 0) {
                        if(!confirm(`Some players in the results file don't exist in current players list. Load anyway? (Results with missing players will be skipped)`)) {
                            return;
                        }
                        // Filter out results with missing players
                        validResults = data.filter(r =>
                            playerIds.has(r.p1Id) && playerIds.has(r.p2Id)
                        );
                    }

                    if(append) {
                        // Append mode: adjust IDs to avoid conflicts
                        const idOffset = nextResultId;
                        const appendedResults = validResults.map(r => ({
                            ...r,
                            id: r.id + idOffset - 1
                        }));
                        results = [...results, ...appendedResults];

                        // Update nextResultId
                        if(results.length > 0) {
                            nextResultId = Math.max(...results.map(r => r.id)) + 1;
                        }

                        renderResultsTable();
                        alert(`Successfully appended ${appendedResults.length} game result(s). Total: ${results.length}`);
                    } else {
                        // Override mode: replace all results
                        results = validResults;

                        // Update nextResultId
                        if(results.length > 0) {
                            nextResultId = Math.max(...results.map(r => r.id)) + 1;
                        }

                        renderResultsTable();
                        alert('Game results loaded successfully');
                    }
                } catch(err) {
                    alert('Error reading game results file: ' + err.message);
                }
            };
            reader.readAsText(file);
        }

        function downloadGameResults(){
            if(!results.length) {
                alert('No game results to download');
                return;
            }
            const data = JSON.stringify(results, null, 2);
            triggerDownload(data, 'game_results.json');
        }

        /******************************
         * Player Report Generation
         ******************************/
        function openPlayerReportModal(){
            if(!players.length){ alert('No players available'); return; }
            if(!results.length){ alert('No game results to report'); return; }

            showModal({
                title:'Generate Player Report',
                body: playerReportForm(),
                confirmText:'Generate',
                onConfirm: ()=>{
                    const form = document.getElementById('playerReportForm');
                    const checkboxes = form.querySelectorAll('input[name="playerIds"]:checked');
                    const selectAll = form.querySelector('input[name="selectAll"]').checked;

                    let selectedPlayerIds = [];

                    if(selectAll){
                        // Generate report for all players
                        selectedPlayerIds = players.map(p => p.id);
                    } else {
                        // Get selected players from checkboxes
                        selectedPlayerIds = Array.from(checkboxes).map(cb => parseInt(cb.value));
                    }

                    if(!selectedPlayerIds.length){
                        alert('Please select at least one player');
                        return false;
                    }

                    generateMultiPlayerReports(selectedPlayerIds);
                    return true;
                }
            });
        }

        function playerReportForm(){
            let html = `<form id="playerReportForm">`;
            html += `<div style="margin-bottom:12px;">`;
            html += `<label style="display:flex; align-items:center; gap:8px; font-weight:bold; cursor:pointer;">`;
            html += `<input type="checkbox" name="selectAll" onchange="toggleAllPlayers(this)"> Select All Players`;
            html += `</label>`;
            html += `</div>`;
            html += `<div style="max-height:300px; overflow-y:auto; border:1px solid var(--border); padding:8px; border-radius:4px;">`;

            players.forEach(p => {
                html += `<div style="margin-bottom:6px;">`;
                html += `<label style="display:flex; align-items:center; gap:8px; cursor:pointer;">`;
                html += `<input type="checkbox" name="playerIds" value="${p.id}" class="player-checkbox">`;
                html += `#${p.id} - ${escapeHtml(p.name)} (${p.category}, ${p.rating})`;
                html += `</label>`;
                html += `</div>`;
            });

            html += `</div>`;
            html += `</form>`;
            return html;
        }

        function toggleAllPlayers(checkbox){
            const form = document.getElementById('playerReportForm');
            const playerCheckboxes = form.querySelectorAll('input[name="playerIds"]');
            playerCheckboxes.forEach(cb => cb.checked = checkbox.checked);
        }

        function generateMultiPlayerReports(playerIds){
            const allReportsData = [];
            const combinedReportText = [];
            const timestamp = getFormattedTimestamp();

            // Generate reports for each selected player
            playerIds.forEach((playerId, index) => {
                const reportData = generateSinglePlayerReportData(playerId);
                if(reportData){
                    allReportsData.push(reportData);
                    combinedReportText.push(reportData.reportText);
                }
            });

            if(allReportsData.length === 0){
                alert('No reports generated (no games found for selected players)');
                return;
            }

            // Generate combined text file (single player or multiple)
            let textReport;
            let textFilename;

            if(playerIds.length === 1){
                // Single player - use their name in filename
                textReport = combinedReportText[0];
                textFilename = `player_report_${allReportsData[0].playerName.replace(/\s+/g, '_')}_${timestamp}.txt`;
            } else {
                // Multiple players - combine all reports
                textReport = combinedReportText.join('\n\n' + '='.repeat(80) + '\n\n');
                textFilename = `player_reports_${timestamp}.txt`;
            }

            triggerDownload(textReport, textFilename);

            // Generate JSON file with all data
            const jsonData = {
                generatedAt: new Date().toISOString(),
                timestamp: timestamp,
                reportCount: allReportsData.length,
                reports: allReportsData.map(data => ({
                    playerId: data.playerId,
                    playerName: data.playerName,
                    category: data.category,
                    currentRating: data.currentRating,
                    statistics: {
                        totalGames: data.totalGames,
                        wins: data.wins,
                        losses: data.losses,
                        draws: data.draws,
                        winPercentage: data.winPercentage,
                        totalRatingChange: data.totalRatingChange
                    },
                    games: data.games
                }))
            };

            const jsonFilename = `player_reports_data_${timestamp}.json`;
            triggerDownload(JSON.stringify(jsonData, null, 2), jsonFilename);

            alert(`Generated ${allReportsData.length} report(s) successfully!`);
        }

        function getFormattedTimestamp(){
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hour = String(now.getHours()).padStart(2, '0');
            const minute = String(now.getMinutes()).padStart(2, '0');
            const second = String(now.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day}-${hour}-${minute}-${second}`;
        }

        function generateSinglePlayerReportData(playerId){
            const player = players.find(p=>p.id===playerId);
            if(!player) return null;

            // Find all games for this player
            const playerGames = results.filter(r => r.p1Id === playerId || r.p2Id === playerId);

            if(!playerGames.length){
                return null;
            }

            // Calculate statistics
            let wins = 0, losses = 0, draws = 0;
            let gamesDetails = [];
            let totalRatingChange = 0;
            let gamesList = [];

            playerGames.forEach(r => {
                const isPlayer1 = r.p1Id === playerId;
                const opponent = isPlayer1 ? players.find(p=>p.id===r.p2Id) : players.find(p=>p.id===r.p1Id);
                const opponentName = opponent ? opponent.name : 'Unknown';
                const opponentId = opponent ? opponent.id : null;

                let result = '';
                let ratingChange = 0;

                if(r.outcome === 'DRAW'){
                    draws++;
                    result = 'Drew';
                } else if((r.outcome === 'P1' && isPlayer1) || (r.outcome === 'P2' && !isPlayer1)){
                    wins++;
                    result = 'Won';
                } else {
                    losses++;
                    result = 'Lost';
                }

                // Get rating change if applied
                if(r.applied){
                    ratingChange = isPlayer1 ? r.deltaP1 : r.deltaP2;
                    totalRatingChange += ratingChange;
                }

                const ratingChangeStr = r.applied ? (ratingChange > 0 ? ` (+${ratingChange})` : ` (${ratingChange})`) : '';
                gamesDetails.push(`  Game #${r.id}: ${result} against ${opponentName}${ratingChangeStr}`);

                // Store game data for JSON
                gamesList.push({
                    gameId: r.id,
                    result: result,
                    opponentId: opponentId,
                    opponentName: opponentName,
                    ratingChange: r.applied ? ratingChange : null,
                    applied: r.applied
                });
            });

            // Build report text
            let report = `PLAYER PERFORMANCE REPORT\n`;
            report += `${'='.repeat(60)}\n\n`;
            report += `Player: ${player.name} (#${player.id})\n`;
            report += `Category: ${player.category}\n`;
            report += `Current Rating: ${player.rating}\n`;
            report += `\n`;
            report += `SUMMARY\n`;
            report += `${'-'.repeat(60)}\n`;
            report += `Total Games Played: ${playerGames.length}\n`;
            report += `  Wins: ${wins}\n`;
            report += `  Losses: ${losses}\n`;
            report += `  Draws: ${draws}\n`;

            if(totalRatingChange !== 0){
                report += `\nTotal Rating Change: ${totalRatingChange > 0 ? '+' : ''}${totalRatingChange} points\n`;
            }

            // Calculate win percentage
            const winPercentage = playerGames.length > 0 ? ((wins + draws * 0.5) / playerGames.length * 100).toFixed(1) : 0;
            report += `Win Percentage: ${winPercentage}%\n`;

            report += `\n`;
            report += `GAME DETAILS\n`;
            report += `${'-'.repeat(60)}\n`;
            report += gamesDetails.join('\n');
            report += `\n\n`;
            report += `Report generated: ${new Date().toLocaleString()}\n`;

            return {
                playerId: player.id,
                playerName: player.name,
                category: player.category,
                currentRating: player.rating,
                totalGames: playerGames.length,
                wins: wins,
                losses: losses,
                draws: draws,
                winPercentage: parseFloat(winPercentage),
                totalRatingChange: totalRatingChange,
                games: gamesList,
                reportText: report
            };
        }

        function generatePlayerReport(playerId){
            // Legacy function - kept for compatibility, redirects to new system
            generateMultiPlayerReports([playerId]);
        }

        /******************************
         * Modal Utility
         ******************************/
        function showModal({title, body, onConfirm, onCancel, confirmText='Save', confirmClass='', cancelText='Cancel'}){
            const root=document.getElementById('modalRoot');
            const backdrop=document.createElement('div'); backdrop.className='modal-backdrop';
            const modal=document.createElement('div'); modal.className='modal';
            modal.innerHTML = `<header>${title}</header><div class="content">${body}</div>`+
                `<div class="actions">`+
                `<button onclick="cancelModal(this)" class="outline">${cancelText}</button>`+
                `<button class="${confirmClass}" onclick="confirmModal(this)">${confirmText}</button>`+
                `</div>`;
            backdrop.appendChild(modal);
            root.appendChild(backdrop);
            backdrop.querySelector('input,select,textarea');
            backdrop._onConfirm = onConfirm;
            backdrop._onCancel = onCancel;
        }
        function closeModal(btn){ const backdrop=btn.closest('.modal-backdrop'); backdrop.remove(); }
        function cancelModal(btn){ const backdrop=btn.closest('.modal-backdrop'); if(!backdrop) return; if(backdrop._onCancel) { backdrop._onCancel(); } backdrop.remove(); }
        function confirmModal(btn){ const backdrop=btn.closest('.modal-backdrop'); if(!backdrop) return; const ok = backdrop._onConfirm? backdrop._onConfirm(): true; if(ok!==false) backdrop.remove(); }

        /******************************
         * Mobile Menu Functions
         ******************************/
        function toggleMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            sidebar.classList.toggle('mobile-open');
            overlay.classList.toggle('show');
        }

        function closeMobileMenu() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            sidebar.classList.remove('mobile-open');
            overlay.classList.remove('show');
        }

        // Close mobile menu when navigation occurs
        function navigate(section) {
            if (section === 'pairing' && players.length < 2) return;
            if (section === 'results' && players.length < 2) return;
            if (section === 'visualization' && players.length < 2) return;

            // Close mobile menu on navigation
            closeMobileMenu();

            document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
            document.getElementById('nav' + capitalize(section)).classList.add('active');
            document.querySelectorAll('.section-view').forEach(el => el.classList.add('hidden'));
            document.getElementById('section' + capitalize(section)).classList.remove('hidden');
            if (section === 'pairing') {
                refreshPairingSelectors();
                renderPairingsTables();
            }
            if (section === 'results') {
                renderResultsTable();
            }
            if (section === 'players') {
                renderPlayersTable();
            }
            if (section === 'visualization') {
                populateVisualizationPlayerSelect();
            }
        }

        /******************************
         * Helpers
         ******************************/
        function escapeHtml(str){ return (str||'').replace(/[&<>"']/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
        function triggerDownload(content, filename){
            const mimeType = filename.endsWith('.json') ? 'application/json;charset=utf-8;' : 'text/csv;charset=utf-8;';
            const blob=new Blob([content],{type:mimeType}); const url=URL.createObjectURL(blob);
            const a=document.createElement('a'); a.href=url; a.download=filename; document.body.appendChild(a); a.click(); setTimeout(()=>{URL.revokeObjectURL(url); a.remove();},1000);
        }

        /******************************
         * JSON Export with Statistics and History
         ******************************/
        function downloadPlayersJSON() {
            if(!players.length) {
                alert('No players to export');
                return;
            }

            // Prompt for tournament date
            showModal({
                title: 'Enter Tournament Date',
                body: `<form id="dateForm">
                    <label>Tournament Date (YYYY-MM-DD)</label>
                    <input name="tournamentDate" type="date" required value="${new Date().toISOString().split('T')[0]}" />
                    <p style="font-size:0.75rem; color:#666; margin-top:8px;">
                        If history exists for this date, it will be updated. Otherwise, a new entry will be added.
                    </p>
                </form>`,
                onConfirm: () => {
                    const form = document.getElementById('dateForm');
                    const dateInput = form.tournamentDate.value.trim();
                    if(!dateInput) {
                        alert('Tournament date is required');
                        return false;
                    }

                    // Validate date format
                    if(!/^\d{4}-\d{2}-\d{2}$/.test(dateInput)) {
                        alert('Date must be in YYYY-MM-DD format');
                        return false;
                    }

                    // Generate and download JSON
                    const json = generatePlayersJSON(dateInput);
                    triggerDownload(json, 'players.json');
                    return true;
                }
            });
        }

        function generatePlayersJSON(tournamentDate) {
            // Calculate statistics for each player based on current results
            const updatedPlayers = players.map(p => {
                const stats = calculatePlayerStatistics(p.id);
                const historyEntry = generateHistoryEntry(p.id, tournamentDate);

                // Merge with existing history
                let history = p.history || [];
                const existingIndex = history.findIndex(h => h.date === tournamentDate);

                if(existingIndex >= 0) {
                    // Overwrite existing entry for this date
                    history[existingIndex] = historyEntry;
                } else {
                    // Append new entry and sort by date
                    history.push(historyEntry);
                    history.sort((a, b) => a.date.localeCompare(b.date));
                }

                return {
                    id: p.id,
                    name: p.name,
                    category: p.category,
                    currentRating: p.rating,
                    initialRating: p.initialRating || (p.category === 'Advanced' ? 1000 : p.category === 'Intermediate' ? 600 : 200),
                    presence: p.presence,
                    teacher: p.teacher,
                    grade: p.grade,
                    statistics: stats,
                    history: history
                };
            });

            // Count players by category
            const categoryCounts = {
                Advanced: updatedPlayers.filter(p => p.category === 'Advanced').length,
                Intermediate: updatedPlayers.filter(p => p.category === 'Intermediate').length,
                Beginner: updatedPlayers.filter(p => p.category === 'Beginner').length
            };

            const output = {
                metadata: {
                    version: "1.0",
                    lastUpdated: new Date().toISOString(),
                    totalPlayers: updatedPlayers.length,
                    categories: categoryCounts
                },
                players: updatedPlayers
            };

            return JSON.stringify(output, null, 2);
        }

        function calculatePlayerStatistics(playerId) {
            const player = players.find(p => p.id === playerId);
            if(!player) return null;

            // Get existing history
            const history = player.history || [];

            // Calculate cumulative statistics from history
            let totalWins = 0, totalLosses = 0, totalDraws = 0;
            let allRatings = [];

            // Process historical data
            history.forEach(h => {
                totalWins += h.results?.wins || 0;
                totalLosses += h.results?.losses || 0;
                totalDraws += h.results?.draws || 0;

                if(h.ratingBefore) allRatings.push(h.ratingBefore);
                if(h.ratingAfter) allRatings.push(h.ratingAfter);
            });

            // Add current session results (not yet in history)
            const currentResults = results.filter(r => r.applied && (r.p1Id === playerId || r.p2Id === playerId));
            let currentWins = 0, currentLosses = 0, currentDraws = 0;
            let currentRatingChange = 0;

            currentResults.forEach(r => {
                const isP1 = r.p1Id === playerId;
                const ratingDelta = isP1 ? (r.deltaP1 || 0) : (r.deltaP2 || 0);

                currentRatingChange += ratingDelta;

                if(r.outcome === 'P1') {
                    if(isP1) currentWins++; else currentLosses++;
                } else if(r.outcome === 'P2') {
                    if(isP1) currentLosses++; else currentWins++;
                } else {
                    currentDraws++;
                }
            });

            // Combine totals
            const wins = totalWins + currentWins;
            const losses = totalLosses + currentLosses;
            const draws = totalDraws + currentDraws;
            const totalGames = wins + losses + draws;

            // Calculate rating range from history + current rating
            allRatings.push(player.rating);
            const initialRating = player.statistics?.initialRating || (allRatings.length > 0 ? Math.min(...allRatings) : player.rating);

            // Add initial rating to the ratings array if not already there
            if(!allRatings.includes(initialRating)) {
                allRatings.push(initialRating);
            }

            const highestRating = allRatings.length > 0 ? Math.max(...allRatings) : player.rating;
            const lowestRating = allRatings.length > 0 ? Math.min(...allRatings) : player.rating;

            // Calculate total rating change from initial to current
            const totalRatingChange = player.rating - initialRating;

            // Calculate current streak (only from current session results)
            let currentStreak = { type: 'none', count: 0 };
            if(currentResults.length > 0) {
                const lastResult = currentResults[currentResults.length - 1];
                const isP1 = lastResult.p1Id === playerId;
                let lastOutcome = '';

                if(lastResult.outcome === 'DRAW') {
                    lastOutcome = 'draw';
                } else if((lastResult.outcome === 'P1' && isP1) || (lastResult.outcome === 'P2' && !isP1)) {
                    lastOutcome = 'win';
                } else {
                    lastOutcome = 'loss';
                }

                currentStreak = { type: lastOutcome, count: 1 };

                // Count streak backwards
                for(let i = currentResults.length - 2; i >= 0; i--) {
                    const r = currentResults[i];
                    const isP1Current = r.p1Id === playerId;
                    let outcome = '';

                    if(r.outcome === 'DRAW') {
                        outcome = 'draw';
                    } else if((r.outcome === 'P1' && isP1Current) || (r.outcome === 'P2' && !isP1Current)) {
                        outcome = 'win';
                    } else {
                        outcome = 'loss';
                    }

                    if(outcome === lastOutcome) {
                        currentStreak.count++;
                    } else {
                        break;
                    }
                }
            }

            const winPercentage = totalGames > 0 ? Math.round((wins / totalGames) * 1000) / 10 : 0;

            return {
                totalGames,
                wins,
                losses,
                draws,
                winPercentage,
                totalRatingChange,
                highestRating,
                lowestRating,
                currentStreak
            };
        }

        function generateHistoryEntry(playerId, tournamentDate) {
            const playerResults = results.filter(r => r.applied && (r.p1Id === playerId || r.p2Id === playerId));
            const player = players.find(p => p.id === playerId);

            if(!player) return null;

            let wins = 0, losses = 0, draws = 0;
            let totalRatingChange = 0;
            const opponents = [];

            playerResults.forEach(r => {
                const isP1 = r.p1Id === playerId;
                const opponentId = isP1 ? r.p2Id : r.p1Id;
                const opponent = players.find(p => p.id === opponentId);
                const ratingDelta = isP1 ? (r.deltaP1 || 0) : (r.deltaP2 || 0);

                totalRatingChange += ratingDelta;

                let result = '';
                if(r.outcome === 'P1') {
                    if(isP1) { wins++; result = 'win'; }
                    else { losses++; result = 'loss'; }
                } else if(r.outcome === 'P2') {
                    if(isP1) { losses++; result = 'loss'; }
                    else { wins++; result = 'win'; }
                } else {
                    draws++;
                    result = 'draw';
                }

                opponents.push({
                    opponentId: opponentId,
                    opponentName: opponent?.name || 'Unknown',
                    result: result,
                    ratingChange: ratingDelta
                });
            });

            const gamesPlayed = wins + losses + draws;
            const ratingBefore = player.statistics?.initialRating || (player.rating - totalRatingChange);
            const ratingAfter = player.rating;

            return {
                date: tournamentDate,
                ratingBefore: ratingBefore,
                ratingAfter: ratingAfter,
                ratingChange: totalRatingChange,
                gamesPlayed: gamesPlayed,
                results: { wins, losses, draws },
                opponents: opponents
            };
        }

        /******************************
         * Visualization Section
         ******************************/
        let currentChart = null;

        function populateVisualizationPlayerSelect() {
            const select = document.getElementById('visualizationPlayerSelect');
            select.innerHTML = '<option value="">-- Select a player --</option>';

            players.forEach(p => {
                const option = document.createElement('option');
                option.value = p.id;
                option.textContent = `#${p.id} - ${p.name} (${p.category})`;
                select.appendChild(option);
            });
        }

        function showPlayerVisualization() {
            const select = document.getElementById('visualizationPlayerSelect');
            const playerId = parseInt(select.value);

            if(!playerId) {
                document.getElementById('playerStatisticsWrapper').innerHTML = '';
                document.getElementById('ratingChartWrapper').innerHTML = '<canvas id="ratingChart" style="max-width:900px; max-height:400px;"></canvas>';
                if(currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
                return;
            }

            const player = players.find(p => p.id === playerId);
            if(!player) return;

            // Display statistics
            displayPlayerStatistics(player);

            // Display rating chart
            displayRatingChart(player);
        }

        function displayPlayerStatistics(player) {
            const wrapper = document.getElementById('playerStatisticsWrapper');
            const stats = player.statistics || calculatePlayerStatistics(player.id);

            let html = '<div style="background:#fff; border:1px solid var(--border); border-radius:var(--radius); padding:20px; max-width:800px;">';
            html += `<h3 style="margin:0 0 16px; font-size:1.2rem;">${escapeHtml(player.name)} - Statistics</h3>`;

            html += '<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:16px; margin-bottom:20px;">';

            // Games Summary
            html += '<div style="background:#f8f9fb; padding:12px; border-radius:4px;">';
            html += '<div style="font-size:0.75rem; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Total Games</div>';
            html += `<div style="font-size:1.8rem; font-weight:700;">${stats.totalGames}</div>`;
            html += '</div>';

            // Win Percentage
            html += '<div style="background:#f8f9fb; padding:12px; border-radius:4px;">';
            html += '<div style="font-size:0.75rem; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Win Rate</div>';
            html += `<div style="font-size:1.8rem; font-weight:700; color:${stats.winPercentage >= 50 ? 'var(--success)' : 'var(--danger)'};">${stats.winPercentage}%</div>`;
            html += '</div>';

            // Rating Change
            html += '<div style="background:#f8f9fb; padding:12px; border-radius:4px;">';
            html += '<div style="font-size:0.75rem; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Rating Change</div>';
            html += `<div style="font-size:1.8rem; font-weight:700; color:${stats.totalRatingChange >= 0 ? 'var(--success)' : 'var(--danger)'};">${stats.totalRatingChange >= 0 ? '+' : ''}${stats.totalRatingChange}</div>`;
            html += '</div>';

            // Current Rating
            html += '<div style="background:#f8f9fb; padding:12px; border-radius:4px;">';
            html += '<div style="font-size:0.75rem; color:#666; text-transform:uppercase; letter-spacing:0.5px; margin-bottom:4px;">Current Rating</div>';
            html += `<div style="font-size:1.8rem; font-weight:700;">${player.rating}</div>`;
            html += '</div>';

            html += '</div>'; // Close grid

            // Detailed breakdown
            html += '<div style="display:grid; grid-template-columns: 1fr 1fr; gap:16px;">';

            html += '<div>';
            html += '<h4 style="margin:0 0 8px; font-size:0.9rem; color:#666;">Record</h4>';
            html += `<div style="font-size:0.85rem;"><strong>Wins:</strong> ${stats.wins}</div>`;
            html += `<div style="font-size:0.85rem;"><strong>Losses:</strong> ${stats.losses}</div>`;
            html += `<div style="font-size:0.85rem;"><strong>Draws:</strong> ${stats.draws}</div>`;
            html += '</div>';

            html += '<div>';
            html += '<h4 style="margin:0 0 8px; font-size:0.9rem; color:#666;">Rating Range</h4>';
            html += `<div style="font-size:0.85rem;"><strong>Highest:</strong> ${stats.highestRating}</div>`;
            html += `<div style="font-size:0.85rem;"><strong>Lowest:</strong> ${stats.lowestRating}</div>`;
            html += `<div style="font-size:0.85rem;"><strong>Current Streak:</strong> ${stats.currentStreak.count} ${stats.currentStreak.type}${stats.currentStreak.count > 1 ? 's' : ''}</div>`;
            html += '</div>';

            html += '</div>'; // Close grid
            html += '</div>'; // Close container

            wrapper.innerHTML = html;
        }

        function displayRatingChart(player) {
            const history = player.history || [];

            if(history.length === 0) {
                document.getElementById('ratingChartWrapper').innerHTML = '<p style="text-align:center; color:#666; padding:40px;">No rating history available for this player.</p>';
                if(currentChart) {
                    currentChart.destroy();
                    currentChart = null;
                }
                return;
            }

            // Prepare chart data
            const labels = history.map(h => h.date);
            const ratingData = history.map(h => h.ratingAfter);

            // Destroy previous chart if exists
            if(currentChart) {
                currentChart.destroy();
            }

            // Create canvas if needed
            const wrapper = document.getElementById('ratingChartWrapper');
            wrapper.innerHTML = '<canvas id="ratingChart" style="max-width:900px; max-height:400px;"></canvas>';

            const ctx = document.getElementById('ratingChart').getContext('2d');

            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Rating',
                        data: ratingData,
                        borderColor: 'rgb(75, 192, 192)',
                        backgroundColor: 'rgba(75, 192, 192, 0.1)',
                        tension: 0.3,
                        fill: true,
                        pointRadius: 5,
                        pointHoverRadius: 7
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `${player.name} - Rating History`,
                            font: { size: 16, weight: 'bold' }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const index = context.dataIndex;
                                    const historyEntry = history[index];
                                    return [
                                        `Games: ${historyEntry.gamesPlayed}`,
                                        `W/L/D: ${historyEntry.results.wins}/${historyEntry.results.losses}/${historyEntry.results.draws}`,
                                        `Change: ${historyEntry.ratingChange >= 0 ? '+' : ''}${historyEntry.ratingChange}`
                                    ];
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Rating'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Tournament Date'
                            }
                        }
                    }
                }
            });
        }

        // Initial render
        renderPlayersTable(); updateNavEnablement();
    </script>
</body>
</html>
